package de.hyronx.matter.compiler.engine

import scala.collection.mutable.Map

import fastparse.parsers.Combinators

import de.hyronx.matter.compiler.parsers.BaseParser
import de.hyronx.matter.compiler.types.Type
import de.hyronx.matter.compiler.ast._

object ParserGenerator {
  import fastparse.all._

  var matterType: MatterTypeTree = BaseBuiltIn

  def apply(contentMap: AST.SyntaxMap, matterType: MatterTypeTree) = {
    this.matterType = matterType

    println(s"~ Parser map: $contentMap")
    // Generate parser from content definitions
    val parserMap = contentMap map {
      case (key, value) ⇒ key → generate(value).log()
    }
    val result = () ⇒ {
      val resultMap = Map.empty[String, Any]

      // Combine all parsers to one
      parserMap.foldLeft(Pass.asInstanceOf[P0]) {
        case (left, (key, parser)) ⇒
          println(s"~ ParserGenerator: Current key = $key, left = $left, right = $parser")
          P(left ~ parser) map {
            case value: Any ⇒
              println(s"~ Got some value: $value")
              resultMap(key) = value
            case something ⇒
              println(s"~ ParserGenerator: Current match = $something, key = $key, left = $left")
          }
      } map (_ ⇒ resultMap)
    }
    result
  }

  def append(parser: P[Any], f: Seq[AST] ⇒ P[Any]) = {

  }

  def generate(astSeq: Seq[AST]): P[String] = {
    astSeq.headOption match {
      case Some(ast) ⇒ ast match {
        case Option(defs) ⇒
          generate(defs).? map (_ ⇒ s"Optional result for $ast")
        case Repeat(defs) ⇒
          generate(defs).rep map (_ ⇒ s"Repeated result for $ast")
        case RepeatOne(defs) ⇒
          generate(defs).rep(1) map (_ ⇒ s"Repeated at least one result for $ast")
        case Range(from, to) ⇒
          CharIn(from to to) ~ generate(astSeq.tail) map (_ ⇒ s"Range: $from to $to result for $ast")
        case Literal(string) ⇒
          string.! ~ generate(astSeq.tail) map (_ ⇒ s"Literal result for $ast")
        case id: TypeName ⇒
          this.matterType.find(id) match {
            case Some(matterType) ⇒
              matterType.parser ~ generate(astSeq.tail) map {
                // TODO: do something with the first part
                case (first, second) ⇒
                  println(s"~ First: ${first.id}, Second: ´$second´ for $ast")
                  second
              }
            case None ⇒
              println(s"~ MatterType not found for $ast")
              Fail
          }
        case _ ⇒
          Fail
      }
      case None ⇒
        Pass map (_ ⇒ s"Pass result because no head left")
    }
  }
}
