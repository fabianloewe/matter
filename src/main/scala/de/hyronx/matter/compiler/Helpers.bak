package de.hyronx.matter.compiler

import de.hyronx.matter.compiler.types._
import de.hyronx.matter.compiler.ast.{ AST, MatterTypeTree, MatterType, BaseBuiltIn }

object Helpers {
  private[compiler] val PARSER_CLASS = "fastparse/core/Parser"
  private[compiler] val PARSER_TYPE = s"L${PARSER_CLASS};"
  private[compiler] val STRING_CLASS = "java/lang/String"
  private[compiler] val STRING_TYPE = s"L${STRING_CLASS};"
  private[compiler] val WRAPPER_CLASS = "de/hyronx/matter/library/FastparseWrapper"
  private[compiler] val OBJECT_TYPE = "Ljava/lang/Object;"

  implicit class VariableTypeConverter(varType: Type) {
    val toJavaClass = varType match {
      case StringType               ⇒ "java/lang/String"
      case TupleType(_) | TupleType ⇒ "scala/Product"
      case StructType(matterType)   ⇒ matterType.toJavaClass
      // Integers are encoded as Java long
      case IntType                  ⇒ "J"
      case VoidType                 ⇒ "V"
      case BoolType                 ⇒ "Z"
      case FloatType                ⇒ "F"
    }

    val toJavaType = {
      if (toJavaClass.length > 1)
        s"L$toJavaClass;"
      else
        toJavaClass
    }
  }

  implicit class MatterTypeConverter(matterType: MatterType) {
    val toJavaClass = {
      def constructHierarchy(mType: MatterTypeTree): List[String] = {
        if (mType == BaseBuiltIn)
          List(BaseBuiltIn.name)
        else
          mType.name :: constructHierarchy(mType.parent)
      }

      constructHierarchy(matterType).reverse.mkString("/")
    }

    val toJavaType = s"L$toJavaClass;"
  }

  implicit class SyntaxASTConverter(ast: AST) {
    import de.hyronx.matter.compiler.ast._

    def getType(syntaxVars: Seq[VariableLike]): Type = {
      def matchSyntax(ast: AST) = ast match {
        case Option(internalDefs)    ⇒ ParserType(GrammarType, OptionalType(internalDefs.getType(syntaxVars)))
        case Repeat(internalDefs)    ⇒ ParserType(GrammarType, ListType(internalDefs.getType(syntaxVars)))
        case RepeatOne(internalDefs) ⇒ ParserType(GrammarType, ListType(internalDefs.getType(syntaxVars)))
        case Literal(string)         ⇒ ParserType(StringType, StringType)
        case Range(from, to)         ⇒ ParserType(GrammarType, StringType)
        case Concatenation(defs)     ⇒ ParserType(GrammarType, TupleType(matchTupleTypes(defs)))
        case Selection(defs)         ⇒ ParserType(GrammarType, matchSelection(defs))
        case VariableUsage(varName) ⇒ syntaxVars find (_.name == varName) match {
          case Some(defs) ⇒ ParserType(GrammarType, defs.getType(syntaxVars))
          case None       ⇒ throw new ParserError(s"No such variable: $varName")
        }
        case matterType: MatterType ⇒ ParserType(GrammarType, StructType(matterType))
        case typeName: TypeName     ⇒ Type(typeName) map (ParserType(GrammarType, _)) getOrElse UnknownType(typeName)
        case other ⇒
          println(s"MappingParser:matchSyntax! Other: $other")
          VoidType
      }

      def matchTupleTypes(ast: Seq[AST]): List[Type] = ast.headOption match {
        case Some(head) ⇒ matchSyntax(head) :: matchTupleTypes(ast.tail)
        case None       ⇒ List()
      }

      def matchSelection(ast: Seq[AST]): Type = {
        val types = ast map (_.getType(syntaxVars))
        if (types forall (_ == types.head)) {
          types.head
        } else {
          UnionType(types)
        }
      }

      matchSyntax(ast)
    }
  }
}
